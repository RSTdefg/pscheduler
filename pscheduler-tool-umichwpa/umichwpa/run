#!/usr/bin/env python3

#
# Development Order #5:
#
# This is the meat and bones of the tool, where the actual desired
# commands or operation will be run. The results are then recorded
# and added to the 'results' JSON data, which will then be sent
# back to the test. Both system and api are able to be used here.
#

import datetime
import subprocess
import json
import sys
import time
import os
import pscheduler
import tempfile

#error and diagnostic tracking
error = []
diags = []
authenticated = False
need_root = True


# from stdin
input = pscheduler.json_load(exit_on_error=True)

# Take input from test spec
try:
    interface = input['test']['spec']['interface']
except KeyError:
    pscheduler.fail('Missing the interface in input')

username = input['test']['spec'].get('username')

password = input['test']['spec'].get('password')

driver = input['test']['spec'].get('driver')

ssid = input['test']['spec'].get('ssid')

bssid = input['test']['spec'].get('bssid')

key_management = input['test']['spec'].get('key_management')


timeout_iso = input['test']['spec'].get('timeout', 'PT10S')
timeout = pscheduler.timedelta_as_seconds( pscheduler.iso8601_as_timedelta(timeout_iso) )
succeeded = False

# create a temporary configuration file
temp = tempfile.NamedTemporaryFile(delete=False, mode='w+t')
tempPath = temp.name
assert os.path.exists(tempPath)
# print(tempPath)
path = tempPath
temp = open(tempPath, "w+t")
temp.writelines(['update_config=1\n','ctrl_interface=/var/run/wpa_supplicant\n',  '\n','network={\n'])
if ssid is not None:
    temp.write('  ssid="' + ssid + '"' + '\n')
if bssid is not None:
    temp.write('  bssid="' + bssid + '"' + '\n')
if password is not None:
    temp.write('  psk="' + password + '"' + '\n')
if key_management is not None:
    temp.write('  key_mgmt=' + key_management + '\n')
temp.write('}')
temp.close()

    #temp.seek(0)

#sleep until designated start time
try:
    pscheduler.sleep_until(input['schedule']['start'])
except KeyError:
    pscheduler.fail('Unable to find start time in input')

# check if the EUID is not the root
if os.geteuid() != 0:
    need_root = True

#remove the interface file if it exists
interface_path = '/var/run/wpa_supplicant' + interface
if os.path.exists(interface_path):
    diags.append('Need root privilage to delete prior interface file')
    clear_interface = ['sudo', 'rm', interface_path]
    # run the commands 
    status, stdout, stderr = pscheduler.run_program(clear_interface, timeout=timeout)
    if status != 0:
        succeeded = False
        fail_json = { 'succeeded': succeeded,
                      'error': 'failed to delete old interface file',
                      'diags':'\n'.join(diags)} 
        pscheduler.succeed_json(fail_json)
        error.append("(failed to delete old interface file) Error returned: \n%s" % stderr.strip('\n'))
    else:
        succeeded = True
        diags.append("Successfully deleted old interface file")
# reset the need root flag as root might not be needed next time
need_root = False

#kill all previous wpa_supplicants
kill_wpa = ['killall', 'wpa_supplicant']
wpa_status = ['sudo', 'ps', 'aux']
kill_wpa.insert(0, 'sudo')
# status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
# print(stdout)

status, stdout, stderr = pscheduler.run_program(kill_wpa, timeout=timeout)
# print("check if process is killed")
# print(stderr)
# status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
# print(stdout)

#run wpa to authenticate
wpa_auth = ['sudo', 'wpa_supplicant', '-i', interface, '-c', path, '-B']
start_time = datetime.datetime.now()
    
if driver is not None:
    wpa_auth.append('-d')
    wpa_auth.append(driver)

# print("here comes the output")
status, stdout, stderr = pscheduler.run_program(wpa_auth, timeout=timeout)
# print(stdout)
# print("stderr:")

# print(stderr)

if status != 0:
    diags.append('Error returned: \n%s' % stderr.strip('\n'))
    succeeded = False
    fail_json = { 'succeeded': succeeded,
              'error': 'failed to run wpa_supplicant, %s' % stderr,
              'diags':'\n'.join(diags)} 
        
    pscheduler.succeed_json(fail_json)
#check if the interface file exists
check_path = ['sudo', 'ls', '/var/run/wpa_supplicant']
status, stdout, stderr = pscheduler.run_program(check_path, timeout=timeout)

#use wpa_cli to check if it was initialized correctly
wpa_status = ["sudo","wpa_cli", '-i', 'wlp0s20f0u11', "status"]
status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
if status != 0:
    error.append('Error: \n%s' % stderr.strip('\n'))
    succeeded = False
    fail_json = { 'succeeded': succeeded,
              'error': 'failed to run wpa_cli to validate the authentication',
              'diags':'\n'.join(diags)} 
    
    succeeded = False
else:
    
    authenticated = True
    succeeded = True

#get the end time for wpa_supplicant to be initialized
end_time = datetime.datetime.now()
# clean up the temporary file

# Organize results into json data
results = {
    'succeeded': succeeded,
    'result': {
        'schema': 1,
        'time': pscheduler.timedelta_as_iso8601( end_time - start_time),
        'succeeded': succeeded,
        'authenticated': authenticated
    },
    'error': error,
    'diags': diags 
}

pscheduler.succeed_json(results)

